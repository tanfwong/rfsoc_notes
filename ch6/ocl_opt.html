

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>6.3. OpenCL Optimization &#8212; Real-time DSP Notes</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'ch6/ocl_opt';</script>
    <link rel="shortcut icon" href="../_static/logo.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7. References" href="../refs.html" />
    <link rel="prev" title="6.2. OpenCL Steps" href="ocl_prog.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Real-Time DSP Applications
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch1/overview.html">1. Overview</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch1/rfsoc4x2.html">1.1. Hardware Platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/vitis.html">1.2. Software Development Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/workflow.html">1.3. Vitis Application Acceleration Development</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch2/hls.html">2. Introduction to HLS</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch2/hls_tasks.html">2.1. HLS Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/hls_flow.html">2.2. Vitis HLS Development Flow</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch3/hls_design.html">3. HLS Design Basics</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch3/metrics.html">3.1. Performance Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/model.html">3.2. Producer-Consumer Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/deadlock.html">3.3. Deadlock</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/dataflow.html">3.4. Data Flow Graph Execution</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch4/hls_prog.html">4. HLS Programming</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch4/functions.html">4.1. Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/loops.html">4.2. Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/arrays.html">4.3. Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/math.html">4.4. Math Data Types</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch5/hls_intf.html">5. HLS Kernel Interface</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch5/gmem.html">5.1. Global Memory Access</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/lcs.html">5.2. Load-Compute-Store Pattern</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="host.html">6. Host Programming</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="opencl.html">6.1. OpenCL Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="ocl_prog.html">6.2. OpenCL Steps</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">6.3. OpenCL Optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refs.html">7. References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/tanfwong/rfsoc_notes" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/tanfwong/rfsoc_notes/issues/new?title=Issue%20on%20page%20%2Fch6/ocl_opt.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/ch6/ocl_opt.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>OpenCL Optimization</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#data-transfer">6.3.1. Data Transfer</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pipelining-data-transfer-and-kernel-execution">6.3.2. Pipelining Data Transfer and Kernel Execution</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parallel-execution-of-kernels">6.3.3. Parallel Execution of Kernels</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="opencl-optimization">
<h1><span class="section-number">6.3. </span>OpenCL Optimization<a class="headerlink" href="#opencl-optimization" title="Permalink to this headline">#</a></h1>
<ul class="simple">
<li><p>In many practical scenarios, the DSP kernel may process a long
sequence of input samples (data) and produce a long sequence of
output samples (data). As the PL has limited memory resources, the
long sequence of input samples will need to be broken down into
shorter blocks. Each shorter input block is passed from the host to
the DSP kernel for processing and then the output block is passed
back from the kernel to the host. This process repeats block by
block until all the blocks generated from the original long input
sequence are processed.</p></li>
<li><p>This block processing approach necessitates the step sequence of
transferring input data from the host memory to the global memory,
executing the kernel to process the data, and transferring the
output data from the global memory back to the host memory (steps
7-9) be repeatedly applied from block to block.</p></li>
<li><p>Since the latency of data transfer and time overhead of launching
the DSP kernel are significantly, sequentially repeating the step
sequence from block to block may significantly reduce the processing
throughput.</p></li>
<li><p>In order to overcome this inefficiency, we need to optimize the OpenCL
host code to support pipelining the steps of data transfer and
kernel execution as well as parallelization with multiple compute
units in the PL.</p></li>
</ul>
<section id="data-transfer">
<span id="sec-data-transfer"></span><h2><span class="section-number">6.3.1. </span>Data Transfer<a class="headerlink" href="#data-transfer" title="Permalink to this headline">#</a></h2>
<ul>
<li><p>Under the OpenCL memory model, data exchange between the host and
the kernels amounts to synchronization of contents between the host
memory and the global memory. As the latency of this memory
synchronization process is significant, it is important to optimize
the performance of  this process.</p></li>
<li><p>The first step of data exchange as discussed in
<a class="reference internal" href="ocl_prog.html#sec-ocl-steps"><span class="std std-numref">Section 6.2</span></a> is to create memory objects (step 6).  i.e.,
allocate buffers (regions) in the global memory for the kernels to
use. There are two main ways to allocate global memory buffers:</p>
<ul>
<li><p><strong>Allocation by XRT</strong>:</p>
<p>This is the method employed in the vector addition example in <a class="reference internal" href="ocl_prog.html#sec-ocl-steps"><span class="std std-numref">Section 6.2</span></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 6: First part</span>
<span class="c1">// These commands will allocate memory on the Device. The cl::Buffer objects can</span>
<span class="c1">// be used to reference the memory locations on the device.</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_ALLOC_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_ALLOC_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_result</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_ALLOC_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>

<span class="p">...</span>

<span class="c1">// Step 6: Second part</span>
<span class="c1">// We then need to map our OpenCL buffers to get the pointers</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_a</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_b</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_result</span><span class="p">;</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">ptr_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMapBuffer</span><span class="p">(</span><span class="n">buffer_a</span><span class="p">,</span>
<span class="w">  </span><span class="n">CL_TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MAP_WRITE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">ptr_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMapBuffer</span><span class="p">(</span><span class="n">buffer_b</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">CL_TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MAP_WRITE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">ptr_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMapBuffer</span><span class="p">(</span><span class="n">buffer_result</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">CL_TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MAP_READ</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
</pre></div>
</div>
<ul class="simple">
<li><p>First, instantiate a <code class="docutils literal notranslate"><span class="pre">cl::Buffer</span></code> memory object using the
<code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code> flag to let XRT allocate the buffer
in the global memory and the corresponding region in the host
memory that is mapped to the global memory buffer, taking
care of all alignment requirements.</p></li>
<li><p>Then, put an <code class="docutils literal notranslate"><span class="pre">enqueueMapBuffer</span></code> command to the command queue
to obtain the handle (pointer) to the mapped region in the
host memory.</p></li>
<li><p>In the example above, <code class="docutils literal notranslate"><span class="pre">buffer_a</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer_b</span></code>, and
<code class="docutils literal notranslate"><span class="pre">buffer_result</span></code> are pointers to the respective buffers in the
global memory while <code class="docutils literal notranslate"><span class="pre">ptr_a</span></code>, <code class="docutils literal notranslate"><span class="pre">ptr_b</span></code>, and <code class="docutils literal notranslate"><span class="pre">ptr_result</span></code> are
pointers to the corresponding mapped regions in the host
memory.</p></li>
</ul>
</li>
<li><p><strong>Allocation by host</strong>:</p>
<p>This method can be explained using this
<a class="reference external" href="https://github.com/Xilinx/Vitis_Accel_Examples/blob/2023.1/host/device_only_buffer/src/host.cpp">example</a>
from the <a class="reference external" href="https://github.com/Xilinx/Vitis_Accel_Examples/tree/2023.1">Vitis repository</a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Use this allocator if user wish to create Buffer/Memory Object with </span>
<span class="c1">// CL_MEM_USE_HOST_PTR to align user buffer to the page boundary. </span>
<span class="c1">// It will ensure that user buffer will be used when user create</span>
<span class="c1">// Buffer/Mem Object with CL_MEM_USE_HOST_PTR.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">aligned_allocator</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>

<span class="w">  </span><span class="n">aligned_allocator</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="n">aligned_allocator</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">aligned_allocator</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">posix_memalign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)))</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">deallocate</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="w">    </span>
<span class="c1">// allocate memory on host for input and output matrices</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">array_size</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">array_size</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">array_size</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">hw_results</span><span class="p">(</span><span class="n">array_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// Allocate Buffer in Global Memory</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_c</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_d</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,</span>
<span class="w">  </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">hw_results</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
</pre></div>
</div>
<ul class="simple">
<li><p>First, instantiate a buffer in the host memory with page
alignment (e.g., use the <code class="docutils literal notranslate"><span class="pre">align</span> <span class="pre">allocator</span></code> template as shown
above).</p></li>
<li><p>Then, instantiate a <code class="docutils literal notranslate"><span class="pre">cl::Buffer</span></code> memory object using the
<code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR</span></code> flag to tell XRT to allocate the buffer
in the global memory and map provided host pointer to the
global memory buffer.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>After the memory objects are created, we can transfer data between
the host and global memory by putting <code class="docutils literal notranslate"><span class="pre">enqueueMigrateMemObjects</span></code>
commands in the command queue to synchronize the contents of the
mapped buffers in the host and global memory as done in the example
in <a class="reference internal" href="ocl_prog.html#sec-ocl-steps"><span class="std std-numref">Section 6.2</span></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 7: Transfer data from host to kernel </span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_a</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span>
<span class="w">  </span><span class="cm">/* 0 means from host*/</span><span class="p">));</span>

<span class="p">...</span><span class="w"> </span>

<span class="c1">// Step 9:</span>
<span class="c1">// The result of the previous kernel execution will need to be retrieved in</span>
<span class="c1">// order to view the results. This call will transfer the data from FPGA to</span>
<span class="c1">// source_results vector</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_result</span><span class="p">},</span><span class="w"> </span>
<span class="w">  </span><span class="n">CL_MIGRATE_MEM_OBJECT_HOST</span><span class="p">));</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The flag <code class="docutils literal notranslate"><span class="pre">CL_MIGRATE_MEM_OBJECT_HOST</span></code> indicates the direction of
migration is from global memory to host memory. If the flag
value is <code class="docutils literal notranslate"><span class="pre">0</span></code>, then the default direction of migration is from
host memory to global memory.</p></li>
</ul>
</li>
</ul>
</section>
<section id="pipelining-data-transfer-and-kernel-execution">
<span id="sec-command-pipeline"></span><h2><span class="section-number">6.3.2. </span>Pipelining Data Transfer and Kernel Execution<a class="headerlink" href="#pipelining-data-transfer-and-kernel-execution" title="Permalink to this headline">#</a></h2>
<ul>
<li><p>Consider again the vector addition example in
<a class="reference internal" href="ocl_prog.html#sec-ocl-steps"><span class="std std-numref">Section 6.2</span></a>, the command queue is set up to operate in
the in-order execution mode by default in the code line</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">CommandQueue</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">CL_QUEUE_PROFILING_ENABLE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
</pre></div>
</div>
<p>Under the in-order execution mode, the two writes to <code class="docutils literal notranslate"><span class="pre">buffer_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">buffer_b</span></code> from the host memory to the global memory have to
complete, one after the other, before the kernel can be
executed. In turn, the execution of the kernel has to complete
before the result can be migrated from <code class="docutils literal notranslate"><span class="pre">buffer_result</span></code> in the
global memory back to the host memory. Thus, if we break down the
addition of two long vectors into processing shorter blocks by calling the
kernel multiple times in the host application, the following
execution timing diagram will result:</p>
<figure class="align-center" id="in-order">
<a class="reference internal image-reference" href="../_images/in-order.png"><img alt="Timing diagram of in-order execution of commands in the command queue" src="../_images/in-order.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.4 </span><span class="caption-text">Timing diagram of in-order execution of commands in the command queue (figure taken from
<span id="id1">[<a class="reference internal" href="../refs.html#id11" title="Vitis Unified Software Platform Documentation: Application Acceleration Development. AMD-Xilinx, Dec. 2023. UG1393 (v2023.2). URL: https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration.">AMD-Xilinx23b</a>]</span>)</span><a class="headerlink" href="#in-order" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>where <code class="docutils literal notranslate"><span class="pre">Wa0</span></code> and <code class="docutils literal notranslate"><span class="pre">Wb0</span></code> stand for writing data from host memory to
<code class="docutils literal notranslate"><span class="pre">buffer_a</span></code> and <code class="docutils literal notranslate"><span class="pre">buffer_b</span></code> in global memory, and <code class="docutils literal notranslate"><span class="pre">Rc0</span></code> stands for
reading data from <code class="docutils literal notranslate"><span class="pre">buffer_result</span></code> in global memory back to host
memory.  We see from the timing diagram that there are large idling
gaps in using the AXI interconnect for data transfer between the
host and the kernel as well as large idling gaps in executing the
kernel in the PL. These idling gaps are due to the latency of data
transfer and that of the kernel. They lower the throughput achieved
by the overall implementation, despite the kernel implementation may
have been optimized.</p>
</li>
<li><p>To increase the throughput of the overall implementation, we can
overlap the data transfer between the host and the kernel and the
execution of the kernel across multiple blocks. In order to achieve
this form of <em>command-level</em> pipelining, we need to:</p>
<ol class="arabic simple">
<li><p>make the command queue operate in the out-of-order execution mode,</p></li>
<li><p>use more buffers, e.g., PIPOs, to store data of multiple blocks, and</p></li>
<li><p>synchronize the sequence of transfer of data from host to
global memory, kernel execution, and transfer of results back
from global to host memory for each block.</p></li>
</ol>
<p>To see how this is done, consider
<a class="reference external" href="https://github.com/Xilinx/Vitis_Accel_Examples/tree/2023.1/host/overlap">this example</a>
from the Vitis repository below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;xcl2.hpp&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">14</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">gen_random</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">default_random_engine</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// An event callback function that prints the operations performed by the OpenCL</span>
<span class="c1">// runtime.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">event_cb</span><span class="p">(</span><span class="n">cl_event</span><span class="w"> </span><span class="n">event1</span><span class="p">,</span><span class="w"> </span><span class="n">cl_int</span><span class="w"> </span><span class="n">cmd_status</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cl_int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">  </span><span class="n">cl_command_type</span><span class="w"> </span><span class="n">command</span><span class="p">;</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="w"> </span><span class="n">event</span><span class="p">(</span><span class="n">event1</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">getInfo</span><span class="p">(</span><span class="n">CL_EVENT_COMMAND_TYPE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">command</span><span class="p">));</span>
<span class="w">  </span><span class="n">cl_int</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">getInfo</span><span class="p">(</span><span class="n">CL_EVENT_COMMAND_EXECUTION_STATUS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">status</span><span class="p">));</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">command_str</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">status_str</span><span class="p">;</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">command</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_COMMAND_READ_BUFFER</span><span class="p">:</span>
<span class="w">      </span><span class="n">command_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;buffer read&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_COMMAND_WRITE_BUFFER</span><span class="p">:</span>
<span class="w">      </span><span class="n">command_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;buffer write&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_COMMAND_NDRANGE_KERNEL</span><span class="p">:</span>
<span class="w">      </span><span class="n">command_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;kernel&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_COMMAND_MAP_BUFFER</span><span class="p">:</span>
<span class="w">      </span><span class="n">command_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;kernel&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_COMMAND_COPY_BUFFER</span><span class="p">:</span>
<span class="w">      </span><span class="n">command_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;kernel&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_COMMAND_MIGRATE_MEM_OBJECTS</span><span class="p">:</span>
<span class="w">      </span><span class="n">command_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;buffer migrate&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="n">command_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;unknown&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_QUEUED</span><span class="p">:</span>
<span class="w">      </span><span class="n">status_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Queued&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_SUBMITTED</span><span class="p">:</span>
<span class="w">      </span><span class="n">status_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Submitted&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_RUNNING</span><span class="p">:</span>
<span class="w">      </span><span class="n">status_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Executing&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">CL_COMPLETE</span><span class="p">:</span>
<span class="w">      </span><span class="n">status_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Completed&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[%s]: %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="n">status_str</span><span class="p">,</span><span class="w"> </span><span class="n">command_str</span><span class="p">);</span>
<span class="w">  </span><span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Sets the callback for a particular event</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">set_callback</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">queue_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cl_int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">setCallback</span><span class="p">(</span><span class="n">CL_COMPLETE</span><span class="p">,</span><span class="w"> </span><span class="n">event_cb</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">queue_name</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Usage: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &lt;XCLBIN File&gt;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">binaryFile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="n">cl_int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">CommandQueue</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Context</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="w"> </span><span class="n">krnl_vadd</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// OPENCL HOST CODE AREA START</span>
<span class="w">  </span><span class="c1">// get_xil_devices() is a utility API which will find the xilinx</span>
<span class="w">  </span><span class="c1">// platforms and will return list of devices connected to Xilinx platform</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Creating Context...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xcl</span><span class="o">::</span><span class="n">get_xil_devices</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// read_binary_file() is a utility API which will load the binaryFile</span>
<span class="w">  </span><span class="c1">// and will return the pointer to file buffer.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">fileBuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xcl</span><span class="o">::</span><span class="n">read_binary_file</span><span class="p">(</span><span class="n">binaryFile</span><span class="p">);</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Program</span><span class="o">::</span><span class="n">Binaries</span><span class="w"> </span><span class="n">bins</span><span class="p">{{</span><span class="n">fileBuf</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">fileBuf</span><span class="p">.</span><span class="n">size</span><span class="p">()}};</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">valid_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">devices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// Creating Context and Command Queue for selected Device</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Context</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// This example will use an out of order command queue. The default command</span>
<span class="w">    </span><span class="c1">// queue created by cl::CommandQueue is an inorder command queue.</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">CommandQueue</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="n">CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Trying to program device[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span>
<span class="w">      </span><span class="n">device</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">CL_DEVICE_NAME</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">cl</span><span class="o">::</span><span class="n">Program</span><span class="w"> </span><span class="n">program</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">device</span><span class="p">},</span><span class="w"> </span><span class="n">bins</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CL_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to program device[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;] with xclbin file!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Device[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]: program successful!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">krnl_vadd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vadd&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">      </span><span class="n">valid_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// we break because we found a valid device</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">valid_device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to program any device found, exit!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// We will break down our problem into multiple iterations. Each iteration</span>
<span class="w">  </span><span class="c1">// will perform computation on a subset of the entire data-set.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">elements_per_iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2048</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">bytes_per_iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements_per_iteration</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">elements_per_iteration</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate memory on the host and fill with random data.</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">);</span>
<span class="w">  </span><span class="n">generate</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="w"> </span><span class="n">end</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="w"> </span><span class="n">gen_random</span><span class="p">);</span>
<span class="w">  </span><span class="n">generate</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">B</span><span class="p">),</span><span class="w"> </span><span class="n">end</span><span class="p">(</span><span class="n">B</span><span class="p">),</span><span class="w"> </span><span class="n">gen_random</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">device_result</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// THIS PAIR OF EVENTS WILL BE USED TO TRACK WHEN A KERNEL IS FINISHED WITH</span>
<span class="w">  </span><span class="c1">// THE INPUT BUFFERS. ONCE THE KERNEL IS FINISHED PROCESSING THE DATA, A NEW</span>
<span class="w">  </span><span class="c1">// SET OF ELEMENTS WILL BE WRITTEN INTO THE BUFFER.</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">kernel_events</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">read_events</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">buffer_c</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">iteration_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iteration_idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_iterations</span><span class="p">;</span><span class="w"> </span><span class="n">iteration_idx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iteration_idx</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iteration_idx</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_events</span><span class="p">[</span><span class="n">flag</span><span class="p">].</span><span class="n">wait</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Allocate Buffer in Global Memory</span>
<span class="w">    </span><span class="c1">// Buffers are allocated using CL_MEM_USE_HOST_PTR for efficient memory and</span>
<span class="w">    </span><span class="c1">// Device-to-host communication</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Creating Buffers...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_READ_ONLY</span><span class="o">|</span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="n">bytes_per_iteration</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">iteration_idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">elements_per_iteration</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_READ_ONLY</span><span class="o">|</span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="n">bytes_per_iteration</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">B</span><span class="p">[</span><span class="n">iteration_idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">elements_per_iteration</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_c</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_WRITE_ONLY</span><span class="o">|</span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="n">bytes_per_iteration</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_result</span><span class="p">[</span><span class="n">iteration_idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">elements_per_iteration</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">write_event</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">krnl_vadd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_c</span><span class="p">[</span><span class="n">flag</span><span class="p">]));</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">krnl_vadd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">[</span><span class="n">flag</span><span class="p">]));</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">krnl_vadd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">[</span><span class="n">flag</span><span class="p">]));</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">krnl_vadd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="n">elements_per_iteration</span><span class="p">)));</span>

<span class="w">    </span><span class="c1">// Copy input data to device global memory</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Copying data (Host to Device)...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Because we are passing the write_event, it returns an event object</span>
<span class="w">    </span><span class="c1">// that identifies this particular command and can be used to query</span>
<span class="w">    </span><span class="c1">// or queue a wait for this particular command to complete.</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_a</span><span class="p">[</span><span class="n">flag</span><span class="p">],</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">[</span><span class="n">flag</span><span class="p">]},</span>
<span class="w">      </span><span class="mi">0</span><span class="w"> </span><span class="cm">/*0 means from host*/</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">write_event</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="w">    </span><span class="n">set_callback</span><span class="p">(</span><span class="n">write_event</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;ooo_queue&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enqueueing NDRange kernel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// This event needs to wait for the write buffer operations to complete</span>
<span class="w">    </span><span class="c1">// before executing. We are sending the write_events into its wait list to</span>
<span class="w">    </span><span class="c1">// ensure that the order of operations is correct.</span>
<span class="w">    </span><span class="c1">// Launch the Kernel</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">waitList</span><span class="p">;</span>
<span class="w">    </span><span class="n">waitList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">write_event</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueNDRangeKernel</span><span class="p">(</span><span class="n">krnl_vadd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="o">&amp;</span><span class="n">waitList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">kernel_events</span><span class="p">[</span><span class="n">flag</span><span class="p">]));</span>
<span class="w">    </span><span class="n">set_callback</span><span class="p">(</span><span class="n">kernel_events</span><span class="p">[</span><span class="n">flag</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;ooo_queue&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Copy Result from Device Global Memory to Host Local Memory</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Getting Results (Device to Host)...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">eventList</span><span class="p">;</span>
<span class="w">    </span><span class="n">eventList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">kernel_events</span><span class="p">[</span><span class="n">flag</span><span class="p">]);</span>
<span class="w">    </span><span class="c1">// This operation only needs to wait for the kernel call. This call will</span>
<span class="w">    </span><span class="c1">// potentially overlap the next kernel call as well as the next read</span>
<span class="w">    </span><span class="c1">// operations</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_c</span><span class="p">[</span><span class="n">flag</span><span class="p">]},</span><span class="w"> </span>
<span class="w">      </span><span class="n">CL_MIGRATE_MEM_OBJECT_HOST</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">eventList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">read_events</span><span class="p">[</span><span class="n">flag</span><span class="p">]));</span>
<span class="w">    </span><span class="n">set_callback</span><span class="p">(</span><span class="n">read_events</span><span class="p">[</span><span class="n">flag</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;ooo_queue&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Wait for all of the OpenCL operations to complete</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Waiting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">flush</span><span class="p">());</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">finish</span><span class="p">());</span>
<span class="w">  </span><span class="c1">// OPENCL HOST CODE AREA ENDS</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Verify the results</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">host_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">device_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">host_result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error: Result mismatch:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;i = %d CPU result = %d Device result = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">host_result</span><span class="p">,</span><span class="w"> </span><span class="n">device_result</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">      </span><span class="n">match</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;TEST %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">match</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;PASSED&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;FAILED&quot;</span><span class="p">));</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">match</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Vectors of length <span class="math notranslate nohighlight">\(2^{14} = 16384\)</span> are broken down into blocks of
length <span class="math notranslate nohighlight">\(2048\)</span> for the vector addition kernel <code class="docutils literal notranslate"><span class="pre">krnl_vadd</span></code> to
operate on.</p></li>
<li><p>PIPO buffers, <code class="docutils literal notranslate"><span class="pre">buffer_a[2]</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer_b[2]</span></code>, and <code class="docutils literal notranslate"><span class="pre">buffer_c[2]</span></code>, are
instantiated to store the input and output blocks of data for
<code class="docutils literal notranslate"><span class="pre">krnl_vadd</span></code> in each iteration of calling <code class="docutils literal notranslate"><span class="pre">krnl_vadd</span></code> to process a
block. The allocation by host approach discussed in
<a class="reference internal" href="#sec-data-transfer"><span class="std std-numref">Section 6.3.1</span></a> is employed to map an alternating
component of the PIPO buffer to the location of the corresponding
block of data in the host memory.</p></li>
<li><p>An out-of-order command queue is instantiated using the
<code class="docutils literal notranslate"><span class="pre">CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</span></code> flag.</p></li>
</ul>
</li>
<li><p>The execution of the example code follows the timing diagram below:</p>
<figure class="align-center" id="out-of-order">
<a class="reference internal image-reference" href="../_images/out-of-order.png"><img alt="Timing diagram of overlapped execution of commands in the command queue" src="../_images/out-of-order.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.5 </span><span class="caption-text">Timing diagram of overlapped execution of commands in the command queue (figure taken from
<span id="id2">[<a class="reference internal" href="../refs.html#id11" title="Vitis Unified Software Platform Documentation: Application Acceleration Development. AMD-Xilinx, Dec. 2023. UG1393 (v2023.2). URL: https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration.">AMD-Xilinx23b</a>]</span>)</span><a class="headerlink" href="#out-of-order" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>where <code class="docutils literal notranslate"><span class="pre">Wak</span></code> and <code class="docutils literal notranslate"><span class="pre">Wbk</span></code> stand for writing data from host memory to the
PIPO buffer components <code class="docutils literal notranslate"><span class="pre">buffer_a[k]</span></code> and <code class="docutils literal notranslate"><span class="pre">buffer_b[k]</span></code> in global
memory, and <code class="docutils literal notranslate"><span class="pre">Rck</span></code> stands for reading data from <code class="docutils literal notranslate"><span class="pre">buffer_result[k]</span></code> in
global memory back to host memory, for <code class="docutils literal notranslate"><span class="pre">k=0,1</span></code>.</p>
<ul>
<li><p>We see that the data transfer and kernel execution overlap in such
a way that the idling gaps between successive executions of the
kernel are significantly shortened, resulting in an increase in
the throughput of the overall implementation.</p></li>
<li><p>Each arrow-linked sequence of operations (issued as commands to
the command queue) in the timing diagram above indicates that the
operations must be performed in order, i.e., the current operation
must be completed before the next operation in the sequence can
start.</p></li>
<li><p>The synchronization of an ordered sequence of commands is achieved
by the use of vectors <code class="docutils literal notranslate"><span class="pre">std::vector&lt;cl::Event&gt;</span></code> of class
<code class="docutils literal notranslate"><span class="pre">cl::Event</span></code> objects, <code class="docutils literal notranslate"><span class="pre">kernel_events</span></code>, <code class="docutils literal notranslate"><span class="pre">read_events</span></code>, and
<code class="docutils literal notranslate"><span class="pre">write_event</span></code>. For example,</p>
<ol class="arabic">
<li><p>The command of transferring data in the host memory to the PIPO
buffers in the global memory is first issued by</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_a</span><span class="p">[</span><span class="n">flag</span><span class="p">],</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">[</span><span class="n">flag</span><span class="p">]},</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">write_event</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">set_callback</span><span class="p">(</span><span class="n">write_event</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;ooo_queue&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>where the event <code class="docutils literal notranslate"><span class="pre">write_event[0]</span></code> is associated with this
command, and the <code class="docutils literal notranslate"><span class="pre">set_callback()</span></code> function is simply a wrapper
to call the class method <code class="docutils literal notranslate"><span class="pre">setCallback()</span></code> of <code class="docutils literal notranslate"><span class="pre">write_event[0]</span></code> to
set up the callback function handler <code class="docutils literal notranslate"><span class="pre">event_cb()</span></code> to print out
information about the execution of the command when it
completes, as set by the <code class="docutils literal notranslate"><span class="pre">CL_COMPLETE</span></code> flag in the first
argument of <code class="docutils literal notranslate"><span class="pre">setCallback()</span></code>.</p>
</li>
<li><p>The command of execution of <code class="docutils literal notranslate"><span class="pre">krnl_vadd</span></code> is then issued by</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">waitList</span><span class="p">;</span>
<span class="n">waitList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">write_event</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueNDRangeKernel</span><span class="p">(</span><span class="n">krnl_vadd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">waitList</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="o">&amp;</span><span class="n">kernel_events</span><span class="p">[</span><span class="n">flag</span><span class="p">]);</span>
<span class="n">set_callback</span><span class="p">(</span><span class="n">kernel_events</span><span class="p">[</span><span class="n">flag</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;ooo_queue&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>where the event <code class="docutils literal notranslate"><span class="pre">kernel_events[flag]</span></code> is associated with this
command, and the command should wait for the event
<code class="docutils literal notranslate"><span class="pre">write_event[0]</span></code> in <code class="docutils literal notranslate"><span class="pre">waitList</span></code> to complete before it starts.</p>
</li>
<li><p>The command of transferring results back from the PIPO buffer
in the global memory is finally issued by</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">eventList</span><span class="p">;</span>
<span class="n">eventList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">kernel_events</span><span class="p">[</span><span class="n">flag</span><span class="p">]);</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_c</span><span class="p">[</span><span class="n">flag</span><span class="p">]},</span><span class="w"> </span>
<span class="w">  </span><span class="n">CL_MIGRATE_MEM_OBJECT_HOST</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">eventList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">read_events</span><span class="p">[</span><span class="n">flag</span><span class="p">]);</span>
<span class="n">set_callback</span><span class="p">(</span><span class="n">read_events</span><span class="p">[</span><span class="n">flag</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;ooo_queue&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>where the event <code class="docutils literal notranslate"><span class="pre">read_events[flag]</span></code> is associated with this
command, and the command should wait for the event <code class="docutils literal notranslate"><span class="pre">kernel_events[flag]</span></code>
in <code class="docutils literal notranslate"><span class="pre">eventList</span></code> to complete before it starts.</p>
</li>
<li><p>Then, in the next iteration that use the same PIPO component
buffers as indicated by the value <code class="docutils literal notranslate"><span class="pre">flag</span></code>, we wait for the command in 3. to
complete using</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_events</span><span class="p">[</span><span class="n">flag</span><span class="p">].</span><span class="n">wait</span><span class="p">();</span>
</pre></div>
</div>
<p>before restarting the sequence of operations.</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</section>
<section id="parallel-execution-of-kernels">
<h2><span class="section-number">6.3.3. </span>Parallel Execution of Kernels<a class="headerlink" href="#parallel-execution-of-kernels" title="Permalink to this headline">#</a></h2>
<ul>
<li><p>Multiple kernels, or compute units generated from the same kernel,
with no data dependence can be executed in parallel using either
multiple in-order command queues or a single out-of-order command
queue.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Multiple symmetrical compute units can be generated from the same
kernel by setting the connectivity argument <code class="docutils literal notranslate"><span class="pre">nk</span></code> in the configuration
file of the kernel. For example, the following lines in the
configuration file of the kernel <code class="docutils literal notranslate"><span class="pre">vadd</span></code> tells Vitis to synthesize 4
symmetricak compute units of <code class="docutils literal notranslate"><span class="pre">vadd</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">connectivity</span><span class="p">]</span>
<span class="n">nk</span><span class="o">=</span><span class="n">vadd</span><span class="p">:</span><span class="mi">4</span>
</pre></div>
</div>
<p>XRT will use all symmetrical compute units interchangeably.</p>
</div>
</li>
<li><p>We focus on the use of a single out-of-order command queue to
support parallel execution of kernels here by considering the
following snippet of host code from<br />
<a class="reference external" href="https://github.com/Xilinx/Vitis_Accel_Examples/tree/2023.1/host/concurrent_kernel_execution">this example</a>
in the Vitis repository (with some modifications):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">out_of_order_queue</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Context</span><span class="o">&amp;</span><span class="w"> </span><span class="n">context</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Device</span><span class="o">&amp;</span><span class="w"> </span><span class="n">device</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="o">&amp;</span><span class="w"> </span><span class="n">kernel_mscale</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="o">&amp;</span><span class="w"> </span><span class="n">kernel_madd</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="o">&amp;</span><span class="w"> </span><span class="n">kernel_mmult</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">buffer_c</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">buffer_d</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">buffer_e</span><span class="p">,</span>
<span class="w">                        </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">buffer_f</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cl_int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ooo_events</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">kernel_wait_events</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// We are creating an out of order queue here.</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">CommandQueue</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">CL_QUEUE_PROFILING_ENABLE</span><span class="o">|</span><span class="n">CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Clear values in the result buffers</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fill_events</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueFillBuffer</span><span class="p">(</span><span class="n">buffer_a</span><span class="p">,</span><span class="w"> </span><span class="n">one</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fill_events</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueFillBuffer</span><span class="p">(</span><span class="n">buffer_c</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fill_events</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueFillBuffer</span><span class="p">(</span><span class="n">buffer_f</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fill_events</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">::</span><span class="n">waitForEvents</span><span class="p">(</span><span class="n">fill_events</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// copy the input arrays to input memory allocated on the accelerator</span>
<span class="w">  </span><span class="c1">// devices</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">matrix_scale_factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mscale</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mscale</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">matrix_scale_factor</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mscale</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">MAT_DIM0</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mscale</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">MAT_DIM1</span><span class="p">));</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[OOO Queue]: Enqueueing scale kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueNDRangeKernel</span><span class="p">(</span><span class="n">kernel_mscale</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">local</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="w">  </span><span class="n">set_callback</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;scale&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// set OpenCL kernel parameters to add scaled matrix A and matrix B</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_madd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_c</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_madd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_madd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_madd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">MAT_DIM0</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_madd</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">MAT_DIM1</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// This is an out of order queue, events can be executed in any order. Since</span>
<span class="w">  </span><span class="c1">// this call depends on the results of the previous call we must pass the</span>
<span class="w">  </span><span class="c1">// event object from the previous call to this kernel&#39;s event wait list.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[OOO Queue]: Enqueueing addition kernel (Depends on scale)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">kernel_wait_events</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">kernel_wait_events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueNDRangeKernel</span><span class="p">(</span><span class="n">kernel_madd</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">local</span><span class="p">,</span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">kernel_wait_events</span><span class="p">,</span><span class="w"> </span><span class="c1">// Event from previous call</span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
<span class="w">  </span><span class="n">set_callback</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;addition&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// set OpenCL kernel parameters to multiply matrix D and E */</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mmult</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_f</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mmult</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_d</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mmult</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_e</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mmult</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">MAT_DIM0</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_mmult</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">MAT_DIM1</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// This call does not depend on previous calls so we are passing nullptr</span>
<span class="w">  </span><span class="c1">// into the event wait list. The runtime should schedule this kernel in</span>
<span class="w">  </span><span class="c1">// parallel to the previous calls.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[OOO Queue]: Enqueueing matrix multiplication kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueNDRangeKernel</span><span class="p">(</span><span class="n">kernel_mmult</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">local</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="c1">// Does not depend on previous call</span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
<span class="w">  </span><span class="n">set_callback</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;matrix multiplication&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">array_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAT_DIM0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">MAT_DIM1</span><span class="p">;</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">array_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">array_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">array_size</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Depends on the addition kernel</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[OOO Queue]: Enqueueing Read Buffer A (depends on addition)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">kernel_wait_events</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">kernel_wait_events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_a</span><span class="p">,</span><span class="w"> </span><span class="n">CL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
<span class="w">                                      </span><span class="o">&amp;</span><span class="n">kernel_wait_events</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
<span class="w">  </span><span class="n">set_callback</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[OOO Queue]: Enqueueing Read Buffer C (depends on addition)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">kernel_wait_events</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">kernel_wait_events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_c</span><span class="p">,</span><span class="w"> </span><span class="n">CL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
<span class="w">                                      </span><span class="o">&amp;</span><span class="n">kernel_wait_events</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">4</span><span class="p">]));</span>
<span class="w">  </span><span class="n">set_callback</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Depends on the matrix multiplication kernel</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span>
<span class="w">      </span><span class="s">&quot;[OOO Queue]: Enqueueing Read Buffer F (depends on matrix &quot;</span>
<span class="w">      </span><span class="s">&quot;multiplication)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">kernel_wait_events</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">kernel_wait_events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_f</span><span class="p">,</span><span class="w"> </span><span class="n">CL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
<span class="w">                                      </span><span class="o">&amp;</span><span class="n">kernel_wait_events</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">5</span><span class="p">]));</span>
<span class="w">  </span><span class="n">set_callback</span><span class="p">(</span><span class="n">ooo_events</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;F&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Block until all operations have completed</span>
<span class="w">  </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
<span class="w">  </span><span class="n">ooo_queue</span><span class="p">.</span><span class="n">finish</span><span class="p">();</span>
<span class="w">  </span><span class="n">verify_results</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Usage: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &lt;XCLBIN File&gt;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">binaryFile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="w">  </span><span class="n">cl_int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Device</span><span class="w"> </span><span class="n">device</span><span class="p">;</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Context</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="w"> </span><span class="n">kernel_madd</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_mscale</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_mmult</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">array_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAT_DIM0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">MAT_DIM1</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// allocate memory on host for input and output matrices</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">array_size</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">array_size</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">D</span><span class="p">(</span><span class="n">array_size</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">E</span><span class="p">(</span><span class="n">array_size</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Called to set environment variables</span>
<span class="w">  </span><span class="c1">// The get_xil_devices will return vector of Xilinx Devices</span>
<span class="w">  </span><span class="c1">// platforms and will return list of devices connected to Xilinx platform</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xcl</span><span class="o">::</span><span class="n">get_xil_devices</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// read_binary_file() is a utility API which will load the binaryFile</span>
<span class="w">  </span><span class="c1">// and will return pointer to file buffer.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">fileBuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xcl</span><span class="o">::</span><span class="n">read_binary_file</span><span class="p">(</span><span class="n">binaryFile</span><span class="p">);</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Program</span><span class="o">::</span><span class="n">Binaries</span><span class="w"> </span><span class="n">bins</span><span class="p">{{</span><span class="n">fileBuf</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">fileBuf</span><span class="p">.</span><span class="n">size</span><span class="p">()}};</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">valid_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">devices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// Creating Context and Command Queue for selected Device</span>
<span class="w">    </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Context</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Trying to program device[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">CL_DEVICE_NAME</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">cl</span><span class="o">::</span><span class="n">Program</span><span class="w"> </span><span class="n">program</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">device</span><span class="p">},</span><span class="w"> </span><span class="n">bins</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CL_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to program device[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;] with xclbin file!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Device[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]: program successful!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_madd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;madd&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">      </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_mscale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mscale&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">      </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_mmult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Kernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mmult&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">      </span><span class="n">valid_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// we break because we found a valid device</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">valid_device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to program any device found, exit!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Allocate Buffer in Global Memory</span>
<span class="w">  </span><span class="c1">// Buffers are allocated using CL_MEM_USE_HOST_PTR for efficient memory and</span>
<span class="w">  </span><span class="c1">// Device-to-host communication</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span>
<span class="w">    </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span>
<span class="w">    </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_c</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_d</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_e</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_USE_HOST_PTR</span><span class="o">|</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
<span class="w">  </span><span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">buffer_f</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>

<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// Use out of order command queue to execute the kernels</span>
<span class="w">  </span><span class="n">out_of_order_queue</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_mscale</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_madd</span><span class="p">,</span>
<span class="w">                     </span><span class="n">kernel_mmult</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_a</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_b</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_c</span><span class="p">,</span><span class="w"> </span>
<span class="w">                     </span><span class="n">buffer_d</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_e</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_f</span><span class="p">,</span><span class="w"> </span><span class="n">size_in_bytes</span><span class="p">);</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;View the timeline trace in Vitis for a visual overview of the</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="w">    </span><span class="s">&quot;execution of this example. Refer to the </span><span class="se">\&quot;</span><span class="s">Timeline Trace</span><span class="se">\&quot;</span><span class="s"> section &quot;</span>
<span class="w">    </span><span class="s">&quot;of</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="w">    </span><span class="s">&quot;the Vitis Development Environment Methodology Guide for additional</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="w">    </span><span class="s">&quot;details.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;TEST PASSED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The host code above executes three kernels, <code class="docutils literal notranslate"><span class="pre">mscale</span></code>, <code class="docutils literal notranslate"><span class="pre">madd</span></code>, and
<code class="docutils literal notranslate"><span class="pre">mmult</span></code>.  One input to <code class="docutils literal notranslate"><span class="pre">madd</span></code> is the output of <code class="docutils literal notranslate"><span class="pre">mscale</span></code>. Hence,
the execution of <code class="docutils literal notranslate"><span class="pre">madd</span></code> must not begin until that of <code class="docutils literal notranslate"><span class="pre">madd</span></code>
completes. On the other hand, the execution of <code class="docutils literal notranslate"><span class="pre">mmult</span></code> is
completely independent of that of <code class="docutils literal notranslate"><span class="pre">mscale</span></code> and <code class="docutils literal notranslate"><span class="pre">madd</span></code>; hence can
be performed in parallel.</p></li>
<li><p>Parallel execution of <code class="docutils literal notranslate"><span class="pre">mmult</span></code> and the sequence <code class="docutils literal notranslate"><span class="pre">mscale</span></code> and <code class="docutils literal notranslate"><span class="pre">madd</span></code>
is implemented using an out-of-order command queue with
<code class="docutils literal notranslate"><span class="pre">cl::Event</span></code> objects to synchronize the execution of <code class="docutils literal notranslate"><span class="pre">mscale</span></code> and
<code class="docutils literal notranslate"><span class="pre">madd</span></code> in sequence. The approach is similar to that employed in
<a class="reference internal" href="#sec-command-pipeline"><span class="std std-numref">Section 6.3.2</span></a>.</p></li>
</ul>
</li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./ch6"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="ocl_prog.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">6.2. </span>OpenCL Steps</p>
      </div>
    </a>
    <a class="right-next"
       href="../refs.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">7. </span>References</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#data-transfer">6.3.1. Data Transfer</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pipelining-data-transfer-and-kernel-execution">6.3.2. Pipelining Data Transfer and Kernel Execution</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parallel-execution-of-kernels">6.3.3. Parallel Execution of Kernels</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Tan F. Wong
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
       Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>