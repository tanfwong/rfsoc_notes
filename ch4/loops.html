

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4.2. Loops &#8212; Real-time DSP Notes</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'ch4/loops';</script>
    <link rel="shortcut icon" href="../_static/logo.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4.3. Arrays" href="arrays.html" />
    <link rel="prev" title="4.1. Functions" href="functions.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Real-Time DSP Applications
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch1/overview.html">1. Overview</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch1/rfsoc4x2.html">1.1. Hardware Platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/vitis.html">1.2. Software Development Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/workflow.html">1.3. Vitis Application Acceleration Development</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch2/hls.html">2. Introduction to HLS</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch2/hls_tasks.html">2.1. HLS Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/hls_flow.html">2.2. Vitis HLS Development Flow</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch3/hls_design.html">3. HLS Design Basics</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch3/metrics.html">3.1. Performance Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/model.html">3.2. Producer-Consumer Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/deadlock.html">3.3. Deadlock</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/dataflow.html">3.4. Data Flow Graph Execution</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="hls_prog.html">4. HLS Programming</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="functions.html">4.1. Functions</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">4.2. Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">4.3. Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html">4.4. Math Data Types</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch5/hls_intf.html">5. HLS Kernel Interface</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch5/gmem.html">5.1. Global Memory Access</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/lcs.html">5.2. Load-Compute-Store Pattern</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch6/host.html">6. Host Programming</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch6/opencl.html">6.1. OpenCL Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch6/ocl_prog.html">6.2. OpenCL Steps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch6/ocl_opt.html">6.3. OpenCL Optimization</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch7/filter.html">7. Filter Implementation</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch7/sfg.html">7.1. Block Diagram &amp; Signal Flow Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/fir.html">7.2. FIR Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/iir.html">7.3. IIR Filter</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refs.html">8. References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/tanfwong/rfsoc_notes" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/tanfwong/rfsoc_notes/issues/new?title=Issue%20on%20page%20%2Fch4/loops.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/ch4/loops.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Loops</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loop-pipelining">4.2.1. Loop Pipelining</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loop-unrolling">4.2.2. Loop Unrolling</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loop-merging">4.2.3. Loop Merging</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nested-loops">4.2.4. Nested Loops</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loop-tripcount">4.2.5. Loop Tripcount</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="loops">
<span id="sec-loops"></span><h1><span class="section-number">4.2. </span>Loops<a class="headerlink" href="#loops" title="Permalink to this headline">#</a></h1>
<p>Loops are standard C/C++ constructs that are ubiquitous in specifying
repetitive operations in a DSP kernel. The two main HLS optimization
techniques for loops are <em>pipelining</em> and <em>unrolling</em>. Pipelining and
unrolling on loops are simply the instruction-level counterparts of
task-level pipelining and parallelization discussed in
<a class="reference internal" href="../ch3/model.html#sec-pro-con"><span class="std std-numref">Section 3.2</span></a>.</p>
<section id="loop-pipelining">
<h2><span class="section-number">4.2.1. </span>Loop Pipelining<a class="headerlink" href="#loop-pipelining" title="Permalink to this headline">#</a></h2>
<ul>
<li><p>By default, Vitis HLS automatically pipelines a loop. We may also
invoke loop pipelining by using <a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/pragma-HLS-pipeline"><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">pipeline</span></code></a>
as shown in the following C++ code snippet from <span id="id1">[<a class="reference internal" href="../refs.html#id12" title="Vitis High-Level Synthesis User Guide. AMD-Xilinx, Dec. 2023. UG1399 (v2023.2). URL: https://docs.xilinx.com/r/en-US/ug1399-vitis-hls.">AMD-Xilinx23a</a>]</span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="nl">vadd</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS pipeline II=1</span>
<span class="w">  </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>It is recommended that we label each loop in the C++ code to
ease the processing and reporting processes by Vitis HLS.</p>
</div>
<ul class="simple">
<li><p>The pipeline pragma above tells Vitis HLS to target at achieving an II
of one clock cycle for the pipeline.</p></li>
<li><p>Suppose it takes one clock cycle to read <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code>, one
clock cycle to add them, and one clock cycle to write to
<code class="docutils literal notranslate"><span class="pre">c[i]</span></code>. Without the pipeline pragma, each iteration of loop
will take 3 clock cycles and the loop’s II=3.</p></li>
<li><p>Since there is no <em><strong>loop dependence</strong></em>, i.e., the next iteration
of the loop may begin before the current iteration completes, the
target II=1 can be achieved by pipelining the loop <code class="docutils literal notranslate"><span class="pre">vadd</span></code> as
shown in the example above.</p></li>
</ul>
</li>
<li><p>Hardware constraints, data dependencies within an iteration, and/or
loop dependencies may prohibit Vitis HLS to achieve the specified II
value for a loop.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<ul class="simple">
<li><p>If the target II value specified in the pipeline pragma can not be
achieved, Vitis HLS may still produce a design with the specified II
value and issue a timing vilation warning message during
synthesis. In some cases, it may generate a design that achieves the
lowest possible II and issue an II violation message instead.</p></li>
<li><p>Not specifying the <code class="docutils literal notranslate"><span class="pre">II=1</span></code> option in the pipeline pragma also sets
the target II to 1; however by not specifying the target II,
Vitis HLS will generate a design that achieves the lowest possible
II and issue an II violation message instead.</p></li>
</ul>
</div>
</li>
<li><p>In some cases, we may be able to re-factor the C++ code forming the
loop to achieve a lower II. For example, consider the loop <code class="docutils literal notranslate"><span class="pre">iir1</span></code>
below that implements a simple first-order IIR filter:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="nl">iir1</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS pipeline II=1</span>
<span class="w">  </span><span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are both <code class="docutils literal notranslate"><span class="pre">int</span></code> arrays containing 100 elements. The
loop <code class="docutils literal notranslate"><span class="pre">iir1</span></code> carries a type of loop dependence called <em>cyclic
dependence</em> where the current iteration of the loop depends on the
results obtained in the previous iterations. The cyclic dependence
could render the specified II=1 not achievable in the <code class="docutils literal notranslate"><span class="pre">iir1</span></code>
loop. Nevertheless, consider re-factoring the loop as below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="nl">iir2</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS pipeline II=1</span>
<span class="w">  </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="w">  </span><span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Assume that each iteration in <code class="docutils literal notranslate"><span class="pre">iir2</span></code> can be completed in 3 clock cycles:</p>
<ul class="simple">
<li><p>In the first clock cycle, <code class="docutils literal notranslate"><span class="pre">x[n]</span></code> is read.</p></li>
<li><p>In the second clock cycle, the division of <code class="docutils literal notranslate"><span class="pre">tmp</span></code>, the addition
with <code class="docutils literal notranslate"><span class="pre">x[n]</span></code>, and the update of <code class="docutils literal notranslate"><span class="pre">tmp</span></code> in the line
<code class="docutils literal notranslate"><span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">tmp/2</span> <span class="pre">+</span> <span class="pre">x[n]</span></code> can all be done. (Note that <code class="docutils literal notranslate"><span class="pre">tmp</span></code> is
instantiated as a register rather than RAM and thus can speed
the operations in this line.)</p></li>
<li><p>In the third clock cycle, <code class="docutils literal notranslate"><span class="pre">y[n]</span></code> is written.</p></li>
</ul>
<p>Then, the specified II=1 can be achieved in spite of the cyclic
dependence. As a matter of fact, Vitis HLS is smart enough to
perform the re-factoring for <code class="docutils literal notranslate"><span class="pre">iir1</span></code> automatically during
synthesis. See Lab 3 for a more in-depth treatment of the above
example.</p>
</li>
<li><p>We may explicitly turn off loop pipelining by putting <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">pipiline</span> <span class="pre">off</span></code> in the loop body.</p></li>
<li><p>We may <em>rewind</em> a pipelined loop to effect continuous execution of
successive calls to the loop by using the option <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">pipeline</span> <span class="pre">rewind</span></code>.  Rewinding can only apply if there is one single
loop inside the top-level function and the code segment before the
loop is executed only once in the pipeline without any conditionals.</p></li>
<li><p>We may also specify the type of pipeline to be used using the
<code class="docutils literal notranslate"><span class="pre">style=</span></code> option. The three possible choices are <code class="docutils literal notranslate"><span class="pre">stp</span></code> standing for a
stall pipeline, <code class="docutils literal notranslate"><span class="pre">flp</span></code> standing for a flushable pipeline, and <code class="docutils literal notranslate"><span class="pre">frp</span></code>
standing for a free-running pipeline. The stall pipeline is the
default choice. See <span id="id2">[<a class="reference internal" href="../refs.html#id12" title="Vitis High-Level Synthesis User Guide. AMD-Xilinx, Dec. 2023. UG1399 (v2023.2). URL: https://docs.xilinx.com/r/en-US/ug1399-vitis-hls.">AMD-Xilinx23a</a>]</span> for details about these three
different pipeline types.</p></li>
<li><p>We may also pipeline the body of a function in the same way that we
pipeline a loop.</p></li>
</ul>
</section>
<section id="loop-unrolling">
<span id="sec-loop-unroll"></span><h2><span class="section-number">4.2.2. </span>Loop Unrolling<a class="headerlink" href="#loop-unrolling" title="Permalink to this headline">#</a></h2>
<ul>
<li><p>Unrolling a loop creates multiple copies of the loop body for
parallelization. Clearly, loop unrolling can reduce the iterative
latency of the loop at the expense of increasing PL resource
utilization.</p></li>
<li><p>We may use <a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/pragma-HLS-unroll"><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">unroll</span></code></a>
in a loop body to tell Vitis HLS to unroll the loop.</p>
<ul class="simple">
<li><p>By default, Vitis HLS keeps all loops rolled unless the unroll
pragma is specified.</p></li>
<li><p>Specifying the pragma with no option will fully unroll the loop
and remove the loop hierarchy. In order the fully unroll a loop,
the loop bound must be known (and fixed) at the build time.</p></li>
<li><p>We may also partially unroll a loop by specifying the <code class="docutils literal notranslate"><span class="pre">factor</span></code>
option in the unroll pragma. For example, <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">unroll</span> <span class="pre">factor=2</span></code> creates 2 copies of the loop body and reduces the trip
count of the loop to a half of the original value. The loop bound
can be variable for a loop to be partially unrolled. In such case
and whenever necessary,
Vitis HLS will add control logic to perform the necessary loop
exit check. We can turn off adding the exit check logic by using
the <code class="docutils literal notranslate"><span class="pre">skip_exit_check</span></code> option.</p></li>
</ul>
</li>
<li><p>For example, by fully unrolling the following loop:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="nl">Loop</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="cp">#pragma HLS unroll </span>
<span class="w">  </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span>
</pre></div>
</div>
<p>Vitis HLS generates a tree of binary adders with a depth of
<span class="math notranslate nohighlight">\(\lceil \log_2 10 \rceil = 4\)</span>. However, we may not see much reduction
in the latency of <code class="docutils literal notranslate"><span class="pre">Loop</span></code> because of limitations in accessing the
elements of array <code class="docutils literal notranslate"><span class="pre">x</span></code> which are stored in RAM. See more discussions
about this in <a class="reference internal" href="arrays.html#sec-arrays"><span class="std std-numref">Section 4.3</span></a> and Lab 3.</p>
</li>
<li><p>We may fully unroll a loop with a variable loop bound by refactoring
the loop to have a constant loop bound. For example, consider the
following loop whose bound <code class="docutils literal notranslate"><span class="pre">N</span></code> is a variable:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="nl">Loop_var</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This loop can not be fully unrolled. However, if we refactor the
loop as below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="nl">Loop_var_fixed</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="cp">#pragma HLS unroll </span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span>
</pre></div>
</div>
<p>then we may fully unroll the loop because its bound is a constant
now.</p>
</li>
</ul>
</section>
<section id="loop-merging">
<h2><span class="section-number">4.2.3. </span>Loop Merging<a class="headerlink" href="#loop-merging" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Each loop creates at least 1 state in the FSM of a DSP kernel. If
there are a sequence of loops in a function of the C++ specification
of the kernel, it takes at least one clock cycle to enter a loop,
another clock cycle to exit the loop and enter the next loop in the
sequence, and so on. <em>Loop merging</em> is the optimization that
merges consecutive loops into a single loop to reduce overall
latency, and to allow potential control logic sharing logic as well
as parallelization if possible.</p></li>
<li><p>Using <a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/pragma-HLS-loop_merge"><code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">HLS</span> <span class="pre">loop_merge</span></code></a>
tells Vitis HLS to merge all loops within the scope the pragma is
placed, conforming to the following set of rules:</p>
<ul>
<li><p>If the loop bounds are variables, they must have the same value,
i.e., the number of iterations of the loops mus be the same.</p></li>
<li><p>If the loop bounds are constants, the maximum is used as the bound of the merged loop.</p></li>
<li><p>Loops with both variable bounds and constant bounds cannot be merged.</p></li>
<li><p>The code between loops to be merged cannot have side effects,
i.e., multiple execution of this code should generate the same results.</p></li>
<li><p>Loops cannot be merged when they contain FIFO reads because
merging may change the order of the reads.</p></li>
</ul>
</li>
</ul>
</section>
<section id="nested-loops">
<h2><span class="section-number">4.2.4. </span>Nested Loops<a class="headerlink" href="#nested-loops" title="Permalink to this headline">#</a></h2>
<ul>
<li><p>Consider pipelining the following pair of nested loops as shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="nl">loop_i</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS pipeline II=1</span>
<span class="w">  </span><span class="nl">loop_j</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Vitis HLS first unrolls the inner loop (<code class="docutils literal notranslate"><span class="pre">loop_j</span></code>) and then
pipelines <code class="docutils literal notranslate"><span class="pre">loop_i</span></code>. Other optimizations may also be applied. For
example, Vitis HLS recognizes that only a single multiplication is
needed per iteration of <code class="docutils literal notranslate"><span class="pre">loop_i</span></code> after unrolling <code class="docutils literal notranslate"><span class="pre">loop_j</span></code>, and
thus it simplifies the RTL design to reduce the amount of PL
resources required to unroll <code class="docutils literal notranslate"><span class="pre">loop_j</span></code>.</p></li>
<li><p>Because the inner loop is unrolled, pipelining the nested loops
this way may significantly increase the amount of PL resources
needed to implement the nested loops.</p></li>
<li><p>Since Vitis HLS automatically pipeline loops, we will obtain the
same synthesized RTL design even if the pipeline pragma in the
code above is absent.</p></li>
</ul>
</li>
<li><p>Another approach to pipeline the nested loops is to <em>flatten</em> them
first and then pipeline the flattened loop. <em>Loop flattening</em> is the
HLS optimization that removes the hierarchy of nested loops to
convert them into a single loop. For example, the nested loops above
can be flattened using <a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/pragma-HLS-loop_flatten"><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">loop_flatten</span></code></a>
as shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="nl">loop_i</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">loop_j</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS loop_flatten</span>
<span class="w">    </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>In this case, Vitis HLS will convert the nested loops, <code class="docutils literal notranslate"><span class="pre">loop_i</span></code> and
<code class="docutils literal notranslate"><span class="pre">loop_j</span></code>, into a single loop <code class="docutils literal notranslate"><span class="pre">loop_i_loop_j</span></code> running through 100
terations.</p></li>
<li><p>Vitis HLS will then automatically pipeline the flattened loop
<code class="docutils literal notranslate"><span class="pre">loop_i_loop_j</span></code>. This approach of “first flatterning and then
pipelining” the nested loops uses significantly less PL resources
because the inner loop is not unrolled. However, it may also
significantly increase the latency since the trip count of the
flatten loop is now the product of those of the nested loops.</p></li>
</ul>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The “first flatterning and then pipelining” in the example
above may also be invoked by replacing the loop-flatten
pragma with a pipeline pragma in the inner loop <code class="docutils literal notranslate"><span class="pre">loop_j</span></code>.
Putting the pipeline pragma in <code class="docutils literal notranslate"><span class="pre">loop_j</span></code> tells Vitis HLS to pipeline
the inner loop. But that can not be done because there is an outer
loop and thus Vitis HLS must flatten the nested loops first before
it can pipeline <code class="docutils literal notranslate"><span class="pre">loop_j</span></code>.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Loop flattening may not be applied to some nested loops. More
specifically, we can classify nested loops into the following 3 categories:</p>
<dl class="glossary simple">
<dt id="term-Perfect-loop-nests">Perfect loop nests<a class="headerlink" href="#term-Perfect-loop-nests" title="Permalink to this term">#</a></dt><dd><ul class="simple">
<li><p>Only the innermost loop has loop body content.</p></li>
<li><p>There is no logic specified between the loop statements.</p></li>
<li><p>All loop bounds are constants.</p></li>
</ul>
</dd>
<dt id="term-Semi-perfect-loop-nests">Semi-perfect loop nests<a class="headerlink" href="#term-Semi-perfect-loop-nests" title="Permalink to this term">#</a></dt><dd><ul class="simple">
<li><p>Only the innermost loop has loop body content.</p></li>
<li><p>There is no logic specified between the loop statements.</p></li>
<li><p>The outermost loop bound is a variable.</p></li>
</ul>
</dd>
<dt id="term-Imperfect-loop-nests">Imperfect loop nests<a class="headerlink" href="#term-Imperfect-loop-nests" title="Permalink to this term">#</a></dt><dd><ul class="simple">
<li><p>Any nested loops that are not perfect or semi-perfect.</p></li>
</ul>
</dd>
</dl>
<p><strong>Only perfect and semi-perfect nested loops may be flattened.</strong></p>
</div>
</li>
<li><p>Both unrolling the inner loop and flattening the nested loops before
pipelining in the examples above have the added advantage reducing
the number of clock cycles going through the loop hierarchy. Recall
that a clock cycle is needed for each entering and each exiting the
inner loop <code class="docutils literal notranslate"><span class="pre">loop_j</span></code>. Thus, a total of 20 additional clock cycles are
expensed in the outer loop <code class="docutils literal notranslate"><span class="pre">loop_i</span></code> just for entering and exiting
<code class="docutils literal notranslate"><span class="pre">loop_j</span></code> as <code class="docutils literal notranslate"><span class="pre">loop_i</span></code> goes through its 10 iterations. Either
unrolling <code class="docutils literal notranslate"><span class="pre">loop_j</span></code> or flattening the nested loops removes the inner
loop from the loop hierarchy and hence save these extra 20 clock
cycles.</p></li>
<li><p>For nested loops with more than 2 levels in the hierarchy, the
same set of rules described above applies.</p>
<ul>
<li><p><strong>Example 1:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="nl">loop_i</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS pipeline II=1</span>
<span class="w">  </span><span class="nl">loop_j</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">loop_k</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>tells Vitis HLS to unroll the inner loops <code class="docutils literal notranslate"><span class="pre">loop_j</span></code> and <code class="docutils literal notranslate"><span class="pre">loop_k</span></code>
and then pipeline <code class="docutils literal notranslate"><span class="pre">loop_i</span></code>.</p>
</li>
<li><p><strong>Example 2:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="nl">loop_i</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">loop_j</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">loop_k</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS loop_flatten</span>
<span class="w">      </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>tells Vitis HLS to flatten all loops into a single loop
<code class="docutils literal notranslate"><span class="pre">loop_i_loop_j_loop_k</span></code> and then pipeline the flattened loop.</p>
</li>
<li><p><strong>Example 3:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="nl">loop_i</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">loop_j</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS loop_flatten</span>
<span class="w">    </span><span class="nl">loop_k</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>tells Vitis to first unroll <code class="docutils literal notranslate"><span class="pre">loop_k</span></code>, then flatten <code class="docutils literal notranslate"><span class="pre">loop_i</span></code> and
<code class="docutils literal notranslate"><span class="pre">loop_j</span></code>, and finally pipeline the flattened loop <code class="docutils literal notranslate"><span class="pre">loop_i_loop_j</span></code>.</p>
</li>
<li><p><strong>Example 4:</strong> By not issuing any pragma,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="nl">loop_i</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">loop_j</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">loop_k</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Vitis HLS optimizes by performing exactly the same steps in
Example 3, trying to tradeoff between reducing latency and
increasing PL resource utilization.</p>
</li>
</ul>
</li>
</ul>
</section>
<section id="loop-tripcount">
<h2><span class="section-number">4.2.5. </span>Loop Tripcount<a class="headerlink" href="#loop-tripcount" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>For a loop with variable bound, Vitis HLS is not able to report the
<em>tripcount</em>, i.e., the number of iterations and the latency of the
loop in the synthesis step because the tripcount is unknown during
synthesis.</p></li>
<li><p>We may use <a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/pragma-HLS-loop_tripcount"><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">loop_tripcount</span></code></a>
to help Vitis HLS to calculate the tripcount and latency of the
loop. There are three options, <code class="docutils literal notranslate"><span class="pre">max=</span></code>, <code class="docutils literal notranslate"><span class="pre">min=</span></code>, and <code class="docutils literal notranslate"><span class="pre">avg=</span></code>, for us to
specify the maximum, minimum, and average tripcount of the
loop. Note that the loop-tripcount pragma does not affect the
synthesis of the kernel code. It solely helps Vitis HLS in reporting its
estimates of the synthesis design’s performance.</p></li>
<li><p>For example, consider the
following loop whose bound <code class="docutils literal notranslate"><span class="pre">N</span></code> is a variable:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="nl">Loop_var</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="cp">#pragma HLS loop_tripcount max=100 min=1 avg=50</span>
<span class="w">  </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>allows Vitis HLS to calculate the maximum, minimum, and average values
for the latency of the loop based on the specified tripcount
values.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./ch4"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="functions.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4.1. </span>Functions</p>
      </div>
    </a>
    <a class="right-next"
       href="arrays.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">4.3. </span>Arrays</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loop-pipelining">4.2.1. Loop Pipelining</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loop-unrolling">4.2.2. Loop Unrolling</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loop-merging">4.2.3. Loop Merging</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nested-loops">4.2.4. Nested Loops</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loop-tripcount">4.2.5. Loop Tripcount</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Tan F. Wong
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>