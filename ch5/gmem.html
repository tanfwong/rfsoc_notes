

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>5.1. Global Memory Access &#8212; Real-time DSP Notes</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'ch5/gmem';</script>
    <link rel="shortcut icon" href="../_static/logo.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. References" href="../refs.html" />
    <link rel="prev" title="5. HLS Kernel Interface" href="hls_intf.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Real-Time DSP Applications
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch1/overview.html">1. Overview</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch1/rfsoc4x2.html">1.1. Hardware Platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/vitis.html">1.2. Software Development Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/workflow.html">1.3. Vitis Application Acceleration Development</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch2/hls.html">2. Introduction to HLS</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch2/hls_tasks.html">2.1. HLS Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/hls_flow.html">2.2. Vitis HLS Development Flow</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch3/hls_design.html">3. HLS Design Basics</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch3/metrics.html">3.1. Performance Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/model.html">3.2. Producer-Consumer Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/deadlock.html">3.3. Deadlock</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/dataflow.html">3.4. Data Flow Graph Execution</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch4/hls_prog.html">4. HLS Programming</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch4/functions.html">4.1. Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/loops.html">4.2. Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/arrays.html">4.3. Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/math.html">4.4. Math Data Types</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="hls_intf.html">5. HLS Kernel Interface</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">5.1. Global Memory Access</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refs.html">6. References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/tanfwong/rfsoc_notes" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/tanfwong/rfsoc_notes/issues/new?title=Issue%20on%20page%20%2Fch5/gmem.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/ch5/gmem.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Global Memory Access</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#port-widening">5.1.1. Port Widening</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#burst-access">5.1.2. Burst Access</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#manual-burst-access">5.1.2.1. Manual Burst Access</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#automatic-burst-access">5.1.2.2. Automatic Burst Access</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="global-memory-access">
<h1><span class="section-number">5.1. </span>Global Memory Access<a class="headerlink" href="#global-memory-access" title="Permalink to this headline">#</a></h1>
<ul>
<li><p>A DSP kernel implemented in the PL exchanges data with the PS host
via global memory (DDR4 on the RFSoC 4x2 board, see
<a class="reference internal" href="../ch1/rfsoc4x2.html#sec-hardware"><span class="std std-numref">Section 1.1</span></a>) that is outside of the RFSoC device.  For
Vitis HLS as discussed before, access to the global memory is
through array (and/or pointer-to-array) arguments of the top-level
function of the DSP kernel. By default, Vitis HLS creates a single
AXI4 memory mapped (<code class="docutils literal notranslate"><span class="pre">m_axi</span></code>) interface, <code class="docutils literal notranslate"><span class="pre">m_axi_gmem</span></code>, through which
access to all the array arguments of the top-level function is
bundled.</p></li>
<li><p>Under the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> protocol:</p>
<ul class="simple">
<li><p>Reading from the global memory must be preceded by a <em>read
request</em>.</p></li>
<li><p>Writing to the global memory must be preceded by a <em>write request</em>
and followed by a <em>write acknowledgement (response)</em>.</p></li>
</ul>
</li>
<li><p>The <em>read latency</em> of the global memory is defined as the time taken
from when the kernel sends out a read request to when the data
requested is received by the kernel. Similarly, the <em>write
latency</em> is defined as the time taken from when the data is
written by the kernel to when the write acknowledgement is
received by the kernel.</p></li>
<li><p>As the global memory is not on-chip, accessing it incurs much more
significant time overheads than accessing local memory on-chip. Both
the read latency and write latency of the global memory are
typically in excess of tens of clock cycles. Thus, if global memory
access is not carefully optimized in the design of a DSP kernel, it
can easily become the performance bottleneck.</p></li>
<li><p>There are three main optimizations that can be performed to increase
the global memory access throughput under the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> protocol:</p>
<ul class="simple">
<li><p><strong>port widening</strong></p></li>
<li><p><strong>burst access</strong></p></li>
<li><p><strong>caching</strong></p></li>
</ul>
<p>Vitis HLS automatically performs the optimization of burst access
and port widening based on its inferencing of the kernel code. If
Vitis HLS fails to infer the possibility of burst access, we may
re-factor the kernel code to perform manual burst access. If manual
burst access does not improve the global memory access throughput,
we may then try caching.</p>
</li>
</ul>
<section id="port-widening">
<span id="sec-port-widen"></span><h2><span class="section-number">5.1.1. </span>Port Widening<a class="headerlink" href="#port-widening" title="Permalink to this headline">#</a></h2>
<ul>
<li><p>The maximum bit-width of an AXI4 port is 512. Thus, setting the
<code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface of the kernel to 512 allows us to read/write 64
bytes per access to the global memory. For example, consider the
following simple top-level function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define N 8000</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">top</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">incr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="nl">RW_Loop</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">out</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">incr</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The arrays <code class="docutils literal notranslate"><span class="pre">in[N]</span></code> and <code class="docutils literal notranslate"><span class="pre">out[N]</span></code> are both mapped to global memory via
the default <code class="docutils literal notranslate"><span class="pre">m_axi_gmem</span></code> port. If the bit-width of <code class="docutils literal notranslate"><span class="pre">m_axi_gmem</span></code> is
set to that of <code class="docutils literal notranslate"><span class="pre">int</span></code> (32), we may only read (write) a single element
of <code class="docutils literal notranslate"><span class="pre">in</span></code> (<code class="docutils literal notranslate"><span class="pre">out</span></code>) per access. However, if the bit-width of
<code class="docutils literal notranslate"><span class="pre">m_axi_gmem</span></code> is widen to 512, we can read (write) 16 elements of
<code class="docutils literal notranslate"><span class="pre">in</span></code> (<code class="docutils literal notranslate"><span class="pre">out</span></code>) per access.</p>
</li>
<li><p>Vitis HLS automatically infers the opportunity to widen the
bit-width of the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> port. In the example above, Vitis HLS will
widen the bit-width of the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> port to the maximum value of 512
and hence only 500 accesses to the global memory are needed to read
(write) the entire array <code class="docutils literal notranslate"><span class="pre">in</span></code> (<code class="docutils literal notranslate"><span class="pre">out</span></code>). We may use the
<code class="docutils literal notranslate"><span class="pre">max_widen_bitwidth=</span></code> option of the interface pragma to set the
maximum bit-width to which Vitis HLS may automatically widen the
<code class="docutils literal notranslate"><span class="pre">m_axi</span></code> port.</p></li>
<li><p>If Vitis HLS fails to automatically widen the bit-width of the
<code class="docutils literal notranslate"><span class="pre">m_axi</span></code> port, we may manually do so by using arrays of the AP
integer, AP fixed point, or <code class="docutils literal notranslate"><span class="pre">hls::vector</span></code> type discussed in
<a class="reference internal" href="../ch4/math.html#sec-math-types"><span class="std std-numref">Section 4.4</span></a> as arguments of the top-level function of
the kernel.</p></li>
</ul>
</section>
<section id="burst-access">
<h2><span class="section-number">5.1.2. </span>Burst Access<a class="headerlink" href="#burst-access" title="Permalink to this headline">#</a></h2>
<ul>
<li><p>Another way to improve global memory access efficiency is to
aggregate multiple accesses to the global memory into a single
<em>burst access</em> in such a way that only a single request (response)
is needed for a sequence of reads (writes) to the global memory.</p></li>
<li><p>In the case of burst access, the <em>read latency</em> is re-defined as the
time taken from when the kernel sends out the read request to when
the first piece of data requested is received by the kernel. The
<em>write latency</em> is defined as the time taken from when the last
piece of data is written by the kernel to when the write
acknowledgement is received by the kernel.</p></li>
<li><p>The figure below shows how the DSP kernel’s <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface
adapter generated by Vitis HLS is connected to the global DDR
memory:</p>
<figure class="align-center" id="gmem">
<a class="reference internal image-reference" href="../_images/gmem.png"><img alt="Interface to global memory" src="../_images/gmem.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.1 </span><span class="caption-text">Connection between the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface of a kernel and the global
DDR memory (figure taken from <span id="id1">[<a class="reference internal" href="../refs.html#id12" title="Vitis High-Level Synthesis User Guide. AMD-Xilinx, Dec. 2023. UG1399 (v2023.2). URL: https://docs.xilinx.com/r/en-US/ug1399-vitis-hls.">AMD-Xilinx23a</a>]</span>)</span><a class="headerlink" href="#gmem" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>During a burst access, a read  request is sent to the
kernel’s <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface adapter, which serves as a buffer for
all read (write) requests generated by the kernel. The <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> may
cut a large access burst into smaller bursts in order to conform
to the 4k-byte access limit and to avoid hogging the AXI
interconnect. A request may take 5 to 7 clock cycles to go through
the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter.</p></li>
<li><p>The request thens routed through the AXI interconnect to the
memory interface generator (MIG), which interfaces the off-chip
DDR memory. Getting through the AXI interconnect may take about 30
clock cycles, and getting to the DDR memory and the getting the
first piece of data back from the memory via the MIG may take 9 to
14 clock cycles.</p></li>
<li><p>The situation is similar for the write request, write data, and
write response sequence. The difference is that read requests are
sent by the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter at the first available chance but a
write request will be queued until the data for all writes in the
burst become available in the buffer of the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter. This
conservative behavior may be changed by setting the configuration
field <code class="docutils literal notranslate"><span class="pre">syn.interface.m_axi_conservative_mode</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code> (false) in
the configuration file of the HLS kernel.</p></li>
<li><p>Overall, the read (write) latency is generally non-deterministic
depending on the arbitration strategy of the AXI interconnect and
the memory access patterns of other hardware components. However,
the value of read (write) latency is at least tens of clock
cycles. Thus, burst access can significantly increases the global
memory access throughput since multiple pieces of data can be
contiguously read (written), needing to suffer the latency of a
single read request (write response).</p></li>
</ul>
</li>
<li><p>The <a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/pragma-HLS-interface">interface
pragma</a>
provides a number of options for us to control and fine tune the buffering and
fragmentation operations for burst access in the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface
adapter to obtain a higher global memory access throughput:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">latency=&lt;value&gt;</span></code> specifies the expected read (write) latency of
the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface, allowing Vitis HLS to initiate a read
(write) request <code class="docutils literal notranslate"><span class="pre">value</span></code> clock cycles before the read (write) is
expected.  The default setting is <code class="docutils literal notranslate"><span class="pre">value=64</span></code>. If the expected
latency is set too low, the read (write) will be ready too soon
and might stall waiting for the global memory. If this figure is
set too high, memory access might be idle waiting on the kernel to
start the read (write).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_read_burst_length=&lt;value&gt;</span></code> specifies the maximum number of
data values read during a burst access. The <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter will
fragment a longer burst to short burst of this length. The default
setting is <code class="docutils literal notranslate"><span class="pre">value=16</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_write_burst_length=&lt;value&gt;</span></code> specifies the maximum number of
data values written during a burst access. The <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter will
fragment a longer burst to short burst of this length. The default
setting is <code class="docutils literal notranslate"><span class="pre">value=16</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_read_outstanding=&lt;value&gt;</span></code> specifies how many read requests
can be made without a response before the AXI4 adapter stalls. This
requires the adapter to have an internal read FIFO buffer of size
<code class="docutils literal notranslate"><span class="pre">num_read_outstanding*max_read_burst_length*data_word_size</span></code>. The
default setting is <code class="docutils literal notranslate"><span class="pre">value=16</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_write_outstanding=&lt;value&gt;</span></code> specifies how many write requests
can be made without a response before the AXI4 adapter stalls. This
requires the adapter to have an internal write FIFO buffer of size
<code class="docutils literal notranslate"><span class="pre">num_write_outstanding*max_write_burst_length*data_word_size</span></code>. The
default setting is <code class="docutils literal notranslate"><span class="pre">value=16</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">channel=&lt;value&gt;</span></code> specifies the channel, identified by the channel
number <code class="docutils literal notranslate"><span class="pre">value</span></code>, in the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter that an array argument of
the top-level function uses.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">depth=&lt;value&gt;</span></code> specifies the maximum number of data values for
the simulated <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter in the test bench to process during
C/RTL co-simulation.</p></li>
</ul>
<p>Unfortunately, the reports generated in the synthesis and
co-simulation steps of the Vitis HLS workflow do not seem to capture
the effects of setting some of these parameters when the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code>
adapter interacts with the global memory. Hence, it may need to test
these settings directly using the hardware on the RFSoC 4x2 board.</p>
</li>
</ul>
<section id="manual-burst-access">
<h3><span class="section-number">5.1.2.1. </span>Manual Burst Access<a class="headerlink" href="#manual-burst-access" title="Permalink to this headline">#</a></h3>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">hls::burst_maxi</span></code> class provides the support for us to implement
burst access to the global memory by manually controlling the burst
access behavior of the kernel. There are two types of burst access,
namely <em>pipeline bursting</em> and <em>sequential bursting</em>, that we may
use the <code class="docutils literal notranslate"><span class="pre">hls::burst_maxi</span></code> class object to implement.</p></li>
<li><p>A <em><strong>pipeline burst</strong></em> is one that the maximum number of pieces of
data are accessed with a single read request (pair of write request
and write response). The “maximum number” here often refers to the
tripcount of a loop. The best way to explain pipeline bursting is to
consider the following example kernel code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;hls_burst_maxi.h&gt;</span>
<span class="cp">#define MAX_N 1000</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">read_task</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">burst_maxi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">in</span><span class="p">.</span><span class="n">read_request</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="w">  </span><span class="nl">Read_Loop</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS loop_tripcount max=MAX_N</span>
<span class="w">    </span><span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">write_task</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">hls</span><span class="o">::</span><span class="n">burst_maxi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">out</span><span class="p">.</span><span class="n">write_request</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="w">  </span><span class="nl">Write_Loop</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS loop_tripcount max=MAX_N</span>
<span class="w">    </span><span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">out</span><span class="p">.</span><span class="n">write_response</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">top</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">burst_maxi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">hls</span><span class="o">::</span><span class="n">burst_maxi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS interface mode=m_axi port=in depth=MAX_N channel=0</span>
<span class="cp">#pragma HLS interface mode=m_axi port=out depth=MAX_N channel=1</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">MAX_N</span><span class="p">];</span>

<span class="cp">#pragma HLS DATAFLOW</span>
<span class="w">  </span><span class="n">read_task</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="w">  </span><span class="n">write_task</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>First, we need to include the header file <code class="docutils literal notranslate"><span class="pre">&lt;hls_burst_maxi.h&gt;</span></code> to
use the <code class="docutils literal notranslate"><span class="pre">hls::burst_maxi&lt;&gt;</span></code> class template.</p></li>
<li><p>In the top-level function <code class="docutils literal notranslate"><span class="pre">top()</span></code>, we employ the
<code class="docutils literal notranslate"><span class="pre">hls::burst_maxi&lt;int&gt;</span></code>-type arguments <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">out</span></code> instead of
array arguments to let Vitis HLS know that we intend to implement
manual burst access.</p></li>
<li><p>Two interface pragmas are used to set the arguments <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">out</span></code>
to use channels <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code> of the default <code class="docutils literal notranslate"><span class="pre">m_axi_gmem</span></code> adapter,
respectively. This is a requirement by VItis HLS that different
<code class="docutils literal notranslate"><span class="pre">hls::burst_maxi&lt;int&gt;</span></code>-type arguments must be on different <code class="docutils literal notranslate"><span class="pre">m_axi</span></code>
adapters or different channels if they are bundled to the same
<code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter. The <code class="docutils literal notranslate"><span class="pre">depth=MAX_N</span></code> options in the pragmas tell
Vitis HLS the maximum number of pieces of data so that it can
reserves enough buffering in the simulated <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter during
the C/RTL co-simulation step.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">read_task()</span></code> function, a single read request is sent to
the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter to request for a burst read of all pieces of
data in the <code class="docutils literal notranslate"><span class="pre">Read_Loop</span></code>.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">write_task()</span></code> function similarly, a single write request
is sent to the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter to request for a burst write of all
pieces of data in the <code class="docutils literal notranslate"><span class="pre">Write_Loop</span></code>. After that, the
<code class="docutils literal notranslate"><span class="pre">write_response()</span></code> method is employed to wait for a single write
response returning from the global memory via the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter.</p></li>
<li><p>Vitis HLS will not change the bit-width of a port synthesized from
an <code class="docutils literal notranslate"><span class="pre">hls::burst_maxi&lt;int&gt;</span></code>-type argument. Thus, automatic port
widening will not be applied in this case.</p></li>
<li><p>A FIFO should be configured to be the streaming buffer between the
<code class="docutils literal notranslate"><span class="pre">read_task()</span></code> and <code class="docutils literal notranslate"><span class="pre">write_task()</span></code> for the dataflow optimization to
work efficiently.</p></li>
</ul>
<p>The testbench code can simply input arrays for the
<code class="docutils literal notranslate"><span class="pre">hls::burst_maxi&lt;int&gt;</span></code>-type arguments when calling the top-level
function, for example as shown in the C++ code snippet below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">Max_N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">Max_N</span><span class="p">];</span>

<span class="p">...</span>

<span class="n">top</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>A <em><strong>sequential burst</strong></em> is one in which a smaller number of pieces of
data are accessed with each single read request (pair of write request
and write response). The sequence of read requests and reads (write
requests, writes, and write responses) are typically all placed with
a loop, as opposed to the case of a pipeline burst. Once again, the
best way to explain a sequential is to consider the following
example kernel code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BURST_LEN 2</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">read_task</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">burst_maxi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="nl">Read_Loop</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">N</span><span class="o">/</span><span class="n">BURST_LEN</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS loop_tripcount max=MAX_N/BURST_LEN</span>
<span class="cp">#pragma HLS pipeline II=BURST_LEN</span>
<span class="w">    </span><span class="n">in</span><span class="p">.</span><span class="n">read_request</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">BURST_LEN</span><span class="p">,</span><span class="w"> </span><span class="n">BURST_LEN</span><span class="p">);</span>
<span class="w">    </span><span class="nl">Read_Burst_Loop</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="n">BURST_LEN</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">BURST_LEN</span><span class="o">+</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">write_task</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">hls</span><span class="o">::</span><span class="n">burst_maxi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="nl">Write_Loop</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">N</span><span class="o">/</span><span class="n">BURST_LEN</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS loop_tripcount max=MAX_N/BURST_LEN</span>
<span class="cp">#pragma HLS pipeline II=BURST_LEN</span>
<span class="w">    </span><span class="n">out</span><span class="p">.</span><span class="n">write_request</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">BURST_LEN</span><span class="p">,</span><span class="w"> </span><span class="n">BURST_LEN</span><span class="p">);</span>
<span class="w">    </span><span class="nl">Read_Burst_Loop</span><span class="p">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="n">BURST_LEN</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">BURST_LEN</span><span class="o">+</span><span class="n">k</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">out</span><span class="p">.</span><span class="n">write_response</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">top</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">burst_maxi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">hls</span><span class="o">::</span><span class="n">burst_maxi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma HLS interface mode=m_axi port=in depth=MAX_N channel=0 num_read_outstanding=36</span>
<span class="cp">#pragma HLS interface mode=m_axi port=out depth=MAX_N channel=1 num_write_outstanding=36</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">MAX_N</span><span class="p">];</span>

<span class="cp">#pragma HLS DATAFLOW</span>
<span class="w">  </span><span class="n">read_task</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="w">  </span><span class="n">write_task</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>With sequential bursting, there may be gaps in accessing the
global memory via the AXI interconnect, and thus may not be as
efficient as pipeline bursting.</p></li>
<li><p>Pipelining the loop helps to reduce these memory access
gaps. However, pipeling the loop may push a stream of read (write)
requests in a row to the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter. Therefore, we may need
to increase the values of <code class="docutils literal notranslate"><span class="pre">num_read_outstanding</span></code> and
<code class="docutils literal notranslate"><span class="pre">num_write_outstanding</span></code> in order to buffer all these requests in
the adapter. Otherwise, the kernel may stall when trying to push
read (write) requests to the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter, creating back more
memory access gaps.</p></li>
</ul>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>The latency estimates given in the synthesis report for burst
access, in particular sequential bursting, may not be accurate
because only the nominal read and write latency values, but not
the behaviors of the <code class="docutils literal notranslate"><span class="pre">m_axi</span></code>adapter, are considered in the
reporting process. More accurate latency estimates are produced
in the C/RTL co-simulation, which models the behaviors of the
<code class="docutils literal notranslate"><span class="pre">m_axi</span></code> adapter.</p>
</div>
</li>
</ul>
</section>
<section id="automatic-burst-access">
<h3><span class="section-number">5.1.2.2. </span>Automatic Burst Access<a class="headerlink" href="#automatic-burst-access" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Vitis HLS automatic performs burst access optimization by inferring
from the kernel code opportunities to implement pipeline and/or
sequential bursting on a per function basis:</p>
<ol class="arabic simple">
<li><p>Vitis HLS first look for sequences of statements that perform
global memory access in the body of a function to implement
sequential bursting across the sequences.</p></li>
<li><p>Vitis HLS then looks at loops to try to infer possibilities of
pipeline bursting. If pipeline bursting can not be inferred for a
loop, Vitis HLS will implement sequential bursting for the loop.</p></li>
</ol>
</li>
<li><p>Vitis HLS will determine pipeline bursting for a loop if all the
following conditions are satisfied:</p>
<ul>
<li><p>The loop must contain either all reads or all writes.</p></li>
<li><p>The memory locations of the reads must be monotonically
increasing as the loop iterates.</p></li>
<li><p>The reads (writes) must be consecutive in memory.</p></li>
<li><p>The number of reads (writes), i.e., the <em>burst length</em>, must be
determined before the read (write) request is sent.</p></li>
<li><p>If more than one array is bundled to the same <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface,
bursting can be implemented only for at most one array in each
direction (read or write) at any given time.</p></li>
<li><p>If in a code region accesses of more than one array in the same
channel and same bundle are in the same direction, no pipeline
bursting will be implemented for any of these accesses.</p></li>
<li><p>There must be no dependence issues between a burst access is
initiated and completed.</p></li>
</ul>
</li>
<li><p>For example, consider the top-level function iin
<a class="reference internal" href="#sec-port-widen"><span class="std std-numref">Section 5.1.1</span></a>. Since there are both reads and writes in
the loop <code class="docutils literal notranslate"><span class="pre">RW_Loop</span></code>, Vitis HLS will automatically implement
sequential bursting with port-widening to 512 bits.</p></li>
</ul>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./ch5"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="hls_intf.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">5. </span>HLS Kernel Interface</p>
      </div>
    </a>
    <a class="right-next"
       href="../refs.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">6. </span>References</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#port-widening">5.1.1. Port Widening</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#burst-access">5.1.2. Burst Access</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#manual-burst-access">5.1.2.1. Manual Burst Access</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#automatic-burst-access">5.1.2.2. Automatic Burst Access</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Tan F. Wong
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>